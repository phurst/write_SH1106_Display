/* i2c - Example

   For other examples please check:
   https://github.com/espressif/esp-idf/tree/master/examples

   See README.md file to get detailed usage of this example.

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/
#include <stdio.h>
#include <string.h>

#include "driver/i2c.h"
#include "esp_log.h"
#include "sdkconfig.h"
#include "sh1106.h"

static const char *TAG = "i2c-example";

#define _I2C_NUMBER(num) I2C_NUM_##num
#define I2C_NUMBER(num) _I2C_NUMBER(num)

#define DELAY_TIME_BETWEEN_ITEMS_MS \
  1000 /*!< delay time between different test items */

#define I2C_MASTER_SCL_IO \
  CONFIG_I2C_MASTER_SCL /*!< gpio number for I2C master clock */
#define I2C_MASTER_SDA_IO \
  CONFIG_I2C_MASTER_SDA /*!< gpio number for I2C master data  */
#define I2C_MASTER_NUM                                                       \
  I2C_NUMBER(CONFIG_I2C_MASTER_PORT_NUM) /*!< I2C port number for master dev \
                                          */
#define I2C_MASTER_FREQ_HZ                                                 \
  10000 /*!< I2C master clock frequency, 10k is slow enough for the cheapo \
           logic analyzer */
#define I2C_MASTER_TX_BUF_DISABLE 0 /*!< I2C master doesn't need buffer */
#define I2C_MASTER_RX_BUF_DISABLE 0 /*!< I2C master doesn't need buffer */

#define WRITE_BIT I2C_MASTER_WRITE /*!< I2C master write */
#define READ_BIT I2C_MASTER_READ   /*!< I2C master read */
#define ACK_CHECK_EN 0x1           /*!< I2C master will check ack from slave*/
#define ACK_CHECK_DIS 0x0 /*!< I2C master will not check ack from slave */
#define ACK_VAL 0x0       /*!< I2C ack value */
#define NACK_VAL 0x1      /*!< I2C nack value */

SemaphoreHandle_t print_mux = NULL;
uint8_t vccstate = SH1106_EXTERNALVCC;

/*
 *the memory buffer for the LCD
 */
static uint8_t buffer[SH1106_LCDHEIGHT * SH1106_LCDWIDTH / 8] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0xC0,
    0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
#if (SH1106_LCDHEIGHT * SH1106_LCDWIDTH > 96 * 16)
    0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00,
    0x80, 0x80, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80,
    0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
    0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
    0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0xE0, 0xFC, 0xFE,
    0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE,
    0xFF, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C,
    0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF, 0xFF, 0xFF, 0x00, 0x38,
    0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
    0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01,
    0x00, 0x00, 0x7F, 0xFF, 0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
    0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xE7, 0xC7, 0xC7, 0x8F, 0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
    0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
    0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03,
    0x03, 0x03, 0x01, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03,
    0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00,
    0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01,
    0x00, 0x00, 0x00, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#if (SH1106_LCDHEIGHT == 64)
    0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x3F, 0x1F, 0x0F, 0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D,
    0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFE, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
    0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFE, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0xFC, 0xFE, 0xFC,
    0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
    0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00,
    0x00, 0x00, 0x00, 0xFC, 0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6,
    0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06, 0x06, 0xFC, 0xFE, 0xFC,
    0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
    0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76,
    0xE6, 0xCE, 0xCC, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00,
    0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C, 0x18, 0x18, 0x0C, 0x06,
    0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
    0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00,
    0x00, 0x0F, 0x0F, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07, 0x07, 0x0C, 0x0C, 0x18,
    0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
#endif
};

/**
 * @brief i2c master initialization
 */
static esp_err_t i2c_master_init(void) {
  int i2c_master_port = I2C_MASTER_NUM;
  i2c_config_t conf = {
      .mode = I2C_MODE_MASTER,
      .sda_io_num = I2C_MASTER_SDA_IO,
      .sda_pullup_en = GPIO_PULLUP_ENABLE,
      .scl_io_num = I2C_MASTER_SCL_IO,
      .scl_pullup_en = GPIO_PULLUP_ENABLE,
      .master.clk_speed = I2C_MASTER_FREQ_HZ,
      // .clk_flags = 0,          /*!< Optional, you can use I2C_SCLK_SRC_FLAG_*
      // flags to choose i2c source clock here. */
  };
  esp_err_t err = i2c_param_config(i2c_master_port, &conf);
  if (err != ESP_OK) {
    return err;
  }
  return i2c_driver_install(i2c_master_port, conf.mode,
                            I2C_MASTER_RX_BUF_DISABLE,
                            I2C_MASTER_TX_BUF_DISABLE, 0);
}

esp_err_t check_SH1106() {
  i2c_cmd_handle_t cmd = i2c_cmd_link_create();
  i2c_master_start(cmd);
  i2c_master_write_byte(cmd, (SH1106_I2C_ADDRESS << 1) | WRITE_BIT,
                        ACK_CHECK_EN);
  i2c_master_stop(cmd);
  esp_err_t ret =
      i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 50 / portTICK_RATE_MS);
  i2c_cmd_link_delete(cmd);
  return ret;
}

esp_err_t sh1106_command(uint8_t commandByte, char *commandName) {
  i2c_cmd_handle_t cmd = i2c_cmd_link_create();
  i2c_master_start(cmd);
  i2c_master_write_byte(cmd, (SH1106_I2C_ADDRESS << 1) | WRITE_BIT,
                        ACK_CHECK_DIS);
  i2c_master_write_byte(cmd, 0, ACK_CHECK_DIS);
  i2c_master_write_byte(cmd, commandByte, ACK_CHECK_EN);
  i2c_master_stop(cmd);
  esp_err_t ret =
      i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 50 / portTICK_RATE_MS);
  i2c_cmd_link_delete(cmd);
  if (ret == ESP_OK) {
    ESP_LOGI(TAG, "COMMAND[%s] SUCCEEDED", commandName);
  } else {
    ESP_LOGI(TAG, "COMMAND[%s] FAILED !!!!!!!!!!!!!!!!!!!!!!!!!!", commandName);
  }
  return ret;
}

esp_err_t sh1106_command_ex(uint8_t commandByte, uint8_t dataByte,
                            char *commandName) {
  i2c_cmd_handle_t cmd = i2c_cmd_link_create();
  i2c_master_start(cmd);
  i2c_master_write_byte(cmd, (SH1106_I2C_ADDRESS << 1) | WRITE_BIT,
                        ACK_CHECK_DIS);
  i2c_master_write_byte(cmd, 0, ACK_CHECK_DIS);
  i2c_master_write_byte(cmd, commandByte, ACK_CHECK_DIS);
  i2c_master_write_byte(cmd, dataByte, ACK_CHECK_EN);
  i2c_master_stop(cmd);
  esp_err_t ret =
      i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 50 / portTICK_RATE_MS);
  i2c_cmd_link_delete(cmd);
  if (ret == ESP_OK) {
    ESP_LOGI(TAG, "COMMAND[%s] SUCCEEDED", commandName);
  } else {
    ESP_LOGI(TAG, "COMMAND[%s] FAILED !!!!!!!!!!!!!!!!!!!!!!!!!!", commandName);
  }
  return ret;
}

// clear everything
void clearDisplay() {
  memset(buffer, 0, (SH1106_LCDWIDTH * SH1106_LCDHEIGHT / 8));
}

esp_err_t display() {
  esp_err_t ret = ESP_OK;
  for (int8_t i = (SH1106_LCDHEIGHT / 8) - 1; i >= 0; i--) {
    // Set page Address
    ret = sh1106_command(0xB0 + i, "SET PAGE ADDRESS (ROW)");
    if (ret != ESP_OK) {
      return ret;
    }
    ret = sh1106_command(SH1106_SETLOWCOLUMN, "SH1106_SETLOWCOLUMN");
    if (ret != ESP_OK) {
      return ret;
    }
    ret = sh1106_command(SH1106_SETHIGHCOLUMN, "SH1106_SETHIGHCOLUMN");
    if (ret != ESP_OK) {
      return ret;
    }

    for (uint16_t j = SH1106_LCDWIDTH; j > 0; j--) {
      i2c_cmd_handle_t cmd = i2c_cmd_link_create();
      i2c_master_start(cmd);
      i2c_master_write_byte(cmd, (SH1106_I2C_ADDRESS << 1) | WRITE_BIT,
                            ACK_CHECK_DIS);
      i2c_master_write_byte(cmd, 0, ACK_CHECK_DIS);
      i2c_master_write_byte(cmd, 0x40,
                            ACK_CHECK_DIS);  // Set display start line

      for (uint8_t x = 0; x < 16; x++) {
        i2c_master_write_byte(cmd,
                              buffer[i * SH1106_LCDWIDTH + SH1106_LCDWIDTH - j],
                              ACK_CHECK_DIS);
        j--;
      }  // x
      j++;

      i2c_master_stop(cmd);
      esp_err_t ret =
          i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 50 / portTICK_RATE_MS);
      i2c_cmd_link_delete(cmd);
      if (ret != ESP_OK) {
        return ret;
      }
    }  // j
  }    // i

  return ret;
}

esp_err_t initialize_SH1106() {
  // esp_err_t ret = sh1106_command(SH1106_DISPLAYOFF, "SH1106_DISPLAYOFF");  //
  // 0xAE
  esp_err_t ret = sh1106_command(SH1106_DISPLAYOFF, "SH1106_DISPLAYOFF");
  if (ret != ESP_OK) {
    return ret;
  }
  ret = sh1106_command_ex(SH1106_SETDISPLAYCLOCKDIV, 0x80,
                          "SH1106_SETDISPLAYCLOCKDIV");
  if (ret != ESP_OK) {
    return ret;
  }
  ret = sh1106_command_ex(SH1106_SETMULTIPLEX, 0x3F, "SH1106_SETMULTIPLEX");
  if (ret != ESP_OK) {
    return ret;
  }
  ret = sh1106_command_ex(SH1106_SETDISPLAYOFFSET, 0x00,
                          "SH1106_SETDISPLAYOFFSET");
  if (ret != ESP_OK) {
    return ret;
  }
  if (vccstate == SH1106_EXTERNALVCC) {
    ret = sh1106_command_ex(SH1106_CHARGEPUMP, 0x10, "SH1106_CHARGEPUMP");
  } else {
    ret = sh1106_command_ex(SH1106_CHARGEPUMP, 0x14, "SH1106_CHARGEPUMP");
  }
  if (ret != ESP_OK) {
    return ret;
  }
  ret = sh1106_command_ex(SH1106_MEMORYMODE, 0x00, "SH1106_MEMORYMODE");
  if (ret != ESP_OK) {
    return ret;
  }
  ret = sh1106_command(SH1106_SEGREMAP | 0x1, "SH1106_SEGREMAP | 0x1");
  if (ret != ESP_OK) {
    return ret;
  }
  ret = sh1106_command(SH1106_COMSCANDEC, "SH1106_COMSCANDEC");
  if (ret != ESP_OK) {
    return ret;
  }
  ret = sh1106_command_ex(SH1106_SETCOMPINS, 0x12, "SH1106_SETCOMPINS");
  if (ret != ESP_OK) {
    return ret;
  }
  if (vccstate == SH1106_EXTERNALVCC) {
    ret = sh1106_command_ex(SH1106_SETCONTRAST, 0x9F, "SH1106_SETCONTRAST");
    ret |= sh1106_command_ex(SH1106_SETPRECHARGE, 0x22, "SH1106_SETPRECHARGE");
  } else {
    ret = sh1106_command_ex(SH1106_SETCONTRAST, 0xCF, "SH1106_SETCONTRAST");
    ret |= sh1106_command_ex(SH1106_SETPRECHARGE, 0xF1, "SH1106_SETPRECHARGE");
  }
  if (ret != ESP_OK) {
    return ret;
  }
  ret = sh1106_command_ex(SH1106_SETVCOMDETECT, 0x40, "SH1106_SETVCOMDETECT");
  if (ret != ESP_OK) {
    return ret;
  }
  ret =
      sh1106_command(SH1106_DISPLAYALLON_RESUME, "SH1106_DISPLAYALLON_RESUME");
  if (ret != ESP_OK) {
    return ret;
  }
  ret = sh1106_command(SH1106_NORMALDISPLAY, "SH1106_NORMALDISPLAY");
  if (ret != ESP_OK) {
    return ret;
  }
  ret = sh1106_command(SH1106_DISPLAYON, "SH1106_DISPLAYON");
  return ret;
}

esp_err_t check_and_report_SH1106() {
  esp_err_t ret = check_SH1106();
  xSemaphoreTake(print_mux, portMAX_DELAY);
  printf("RESULT of check_SH1106: ");
  if (ret == ESP_OK) {
    printf("OK\r\n");
  } else if (ret == ESP_ERR_TIMEOUT) {
    printf("TIMEOUT\r\n");
  } else {
    printf("UNKNOWN %d\r\n", ret);
  }
  xSemaphoreGive(print_mux);
  return ret;
}

void SH1106_task(void *arg) {
  char *task_name = (char *)arg;
  ESP_LOGI(TAG, "TASK[%s] STARTED", task_name);
  int doContinue = 1;
  esp_err_t ret = check_and_report_SH1106();
  if (ret != ESP_OK) {
    ESP_LOGI(TAG, "TASK[%s] check_and_report_SH1106 FAILED", task_name);
    doContinue = 0;
  } else {
    ret = initialize_SH1106();
    if (ret != ESP_OK) {
      ESP_LOGI(TAG, "TASK[%s] initialize_SH1106 FAILED", task_name);
      doContinue = 0;
    }
  }
  int iteration = 0;
  while (doContinue) {
    ESP_LOGI(TAG, "TASK[%s] iteration: %d", task_name, iteration++);
    // Iterative stuff here
    if (iteration == 2) {
      ESP_LOGI(TAG, "TASK[%s] iteration: %d CLEAR DISPLAY", task_name,
               iteration++);
      clearDisplay();
      ret = display();
      if (ret != ESP_OK) {
        ESP_LOGI(TAG, "TASK[%s] display FAILED", task_name);
        doContinue = 0;
      }
    }
    vTaskDelay(SH1106_CHECK_DELAY_MS / portTICK_RATE_MS);
  }
  ESP_LOGI(TAG, "TASK[%s] ENDED", task_name);
  vSemaphoreDelete(print_mux);
  vTaskDelete(NULL);
}

void app_main(void) {
  print_mux = xSemaphoreCreateMutex();

  ESP_ERROR_CHECK(i2c_master_init());
  // xTaskCreate(i2c_test_task, "i2c_test_task_0", 1024 * 2, (void *)0, 10,
  // NULL); xTaskCreate(i2c_test_task, "i2c_test_task_1", 1024 * 2, (void *)1,
  // 10, NULL);
  xTaskCreate(SH1106_task, "SH1106_task", 1024 * 2, (void *)"SH1106_task", 10,
              NULL);
}
